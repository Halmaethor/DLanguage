// http://cui.unige.ch/db-research/Enseignement/analyseinfo/JAVA/BNFindex.html
{
  parserClass="net.masterthought.dlanguage.parser.DLanguageParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="DLanguage"
  psiImplClassSuffix="Impl"
  psiPackage="net.masterthought.dlanguage.psi"
  psiImplPackage="net.masterthought.dlanguage.psi.impl"

  elementTypeHolderClass="net.masterthought.dlanguage.psi.DLanguageTypes"
  elementTypeClass="net.masterthought.dlanguage.psi.DLanguageElementType"
  tokenTypeClass="net.masterthought.dlanguage.psi.DLanguageTokenType"

  generateTokenAccessors=true

  tokens =  [
EOF = "EOF"
INVALID_TOKEN = "INVALID_TOKEN"
LINE_END = "LINE_END"
WHITESPACE = "WHITESPACE"
GROUP_COMMENT = "GROUP_COMMENT"
COMMENT_MULTI = "COMMENT_MULTI"    
COMMENT_NESTED = "COMMENT_NESTED"   
COMMENT_LINE = "COMMENT_LINE"     
DOCCOMMENT_MULTI = "DOCCOMMENT_MULTI" 
DOCCOMMENT_NESTED = "DOCCOMMENT_NESTED"
DOCCOMMENT_LINE = "DOCCOMMENT_LINE"  
SCRIPT_LINE_INTRO = "SCRIPT_LINE_INTRO"
SPECIAL_TOKEN_LINE = "SPECIAL_TOKEN_LINE"
IDENTIFIER = "IDENTIFIER"
STRING_WYSIWYG = "STRING_WYSIWYG"
STRING_DQ = "STRING_DQ"     
STRING_HEX = "STRING_HEX"    
STRING_DELIM = "STRING_DELIM"  
STRING_TOKENS = "STRING_TOKENS" 
CHARACTER = "CHARACTER"
INTEGER_DECIMAL = "INTEGER_DECIMAL" 
INTEGER_BINARY = "INTEGER_BINARY"  
INTEGER_OCTAL = "INTEGER_OCTAL"   
INTEGER_HEX = "INTEGER_HEX"    
FLOAT_DECIMAL = "FLOAT_DECIMAL"
FLOAT_HEX = "FLOAT_HEX"    
OPEN_PARENS = "OPEN_PARENS"
CLOSE_PARENS = "CLOSE_PARENS"
OPEN_BRACE = "OPEN_BRACE"
CLOSE_BRACE = "CLOSE_BRACE"
OPEN_BRACKET = "OPEN_BRACKET"
CLOSE_BRACKET = "CLOSE_BRACKET"
SEMICOLON = "SEMICOLON"
COLON = "COLON"
QUESTION = "QUESTION"
COMMA = "COMMA"
DOLLAR = "DOLLAR"
AT = "AT"
DOT = "DOT"
DOUBLE_DOT = "DOUBLE_DOT"
TRIPLE_DOT = "TRIPLE_DOT"
DECREMENT = "DECREMENT"
INCREMENT = "INCREMENT"
MINUS = "MINUS"
MINUS_ASSIGN = "MINUS_ASSIGN"
PLUS = "PLUS"
PLUS_ASSIGN = "PLUS_ASSIGN"
DIV = "DIV"
DIV_ASSIGN = "DIV_ASSIGN"
STAR = "STAR"
MULT_ASSIGN = "MULT_ASSIGN"
MOD = "MOD"
MOD_ASSIGN = "MOD_ASSIGN"
POW = "POW"
POW_ASSIGN = "POW_ASSIGN"
AND = "AND"
AND_ASSIGN = "AND_ASSIGN"
OR = "OR"
OR_ASSIGN = "OR_ASSIGN"
XOR = "XOR"
XOR_ASSIGN = "XOR_ASSIGN"
CONCAT = "CONCAT"
CONCAT_ASSIGN = "CONCAT_ASSIGN"
LOGICAL_AND = "LOGICAL_AND"
LOGICAL_OR = "LOGICAL_OR"
LAMBDA = "LAMBDA"
ASSIGN = "ASSIGN"
EQUALS = "EQUALS"
NOT = "NOT"
NOT_EQUAL = "NOT_EQUAL"
LESS_THAN = "LESS_THAN"
LESS_EQUAL = "LESS_EQUAL"
GREATER_THAN = "GREATER_THAN"
GREATER_EQUAL = "GREATER_EQUAL"
LESS_GREATER = "LESS_GREATER"
LESS_GREATER_EQUAL = "LESS_GREATER_EQUAL"
UNORDERED_E = "UNORDERED_E"
UNORDERED = "UNORDERED"
UNORDERED_GE = "UNORDERED_GE"
UNORDERED_G = "UNORDERED_G"
UNORDERED_LE = "UNORDERED_LE"
UNORDERED_L = "UNORDERED_L"
LEFT_SHIFT = "LEFT_SHIFT"
LEFT_SHIFT_ASSIGN = "LEFT_SHIFT_ASSIGN"
RIGHT_SHIFT = "RIGHT_SHIFT"
RIGHT_SHIFT_ASSIGN = "RIGHT_SHIFT_ASSIGN"
TRIPLE_RSHIFT = "TRIPLE_RSHIFT"
TRIPLE_RSHIFT_ASSIGN = "TRIPLE_RSHIFT_ASSIGN"
KW_BOOL = "KW_BOOL"
KW_VOID = "KW_VOID"
KW_BYTE = "KW_BYTE"
KW_UBYTE = "KW_UBYTE"
KW_SHORT = "KW_SHORT"
KW_USHORT = "KW_USHORT"
KW_INT = "KW_INT"
KW_UINT = "KW_UINT"
KW_LONG = "KW_LONG"
KW_ULONG = "KW_ULONG"
KW_CENT = "KW_CENT"
KW_UCENT = "KW_UCENT"
KW_CHAR = "KW_CHAR"
KW_WCHAR = "KW_WCHAR"
KW_DCHAR = "KW_DCHAR"
KW_FLOAT = "KW_FLOAT"
KW_DOUBLE = "KW_DOUBLE"
KW_REAL = "KW_REAL"
KW_IFLOAT = "KW_IFLOAT"
KW_IDOUBLE = "KW_IDOUBLE"
KW_IREAL = "KW_IREAL"
KW_CFLOAT = "KW_CFLOAT"
KW_CDOUBLE = "KW_CDOUBLE"
KW_CREAL = "KW_CREAL"
KW_PRIVATE = "KW_PRIVATE"
KW_PACKAGE = "KW_PACKAGE"
KW_PROTECTED = "KW_PROTECTED"
KW_PUBLIC = "KW_PUBLIC"
KW_EXPORT = "KW_EXPORT"
KW_ABSTRACT = "KW_ABSTRACT"
KW_DEPRECATED = "KW_DEPRECATED"
KW_FINAL = "KW_FINAL"
KW_NOTHROW = "KW_NOTHROW"
KW_OVERRIDE = "KW_OVERRIDE"
KW_PURE = "KW_PURE"
KW_SCOPE = "KW_SCOPE"
KW_STATIC = "KW_STATIC"
KW_SYNCHRONIZED = "KW_SYNCHRONIZED"
KW_REF = "KW_REF"
KW_CONST = "KW_CONST"
KW_IMMUTABLE = "KW_IMMUTABLE"
KW_INOUT = "KW_INOUT"
KW_SHARED = "KW_SHARED"
KW_AUTO = "KW_AUTO"
KW_ALIAS = "KW_ALIAS"
KW_ALIGN = "KW_ALIGN"
KW_ASM = "KW_ASM"
KW_ASSERT = "KW_ASSERT"
KW_BODY = "KW_BODY"
KW_BREAK = "KW_BREAK"
KW_CASE = "KW_CASE"
KW_CAST = "KW_CAST"
KW_CATCH = "KW_CATCH"
KW_CLASS = "KW_CLASS"
KW_CONTINUE = "KW_CONTINUE"
KW_DEBUG = "KW_DEBUG"
KW_DEFAULT = "KW_DEFAULT"
KW_DELEGATE = "KW_DELEGATE"
KW_DELETE = "KW_DELETE"
KW_DO = "KW_DO"
KW_ELSE = "KW_ELSE"
KW_ENUM = "KW_ENUM"
KW_EXTERN = "KW_EXTERN"
KW_FALSE = "KW_FALSE"
KW_FINALLY = "KW_FINALLY"
KW_FOR = "KW_FOR"
KW_FOREACH = "KW_FOREACH"
KW_FOREACH_REVERSE = "KW_FOREACH_REVERSE"
KW_FUNCTION = "KW_FUNCTION"
KW_GOTO = "KW_GOTO"
KW_IF = "KW_IF"
KW_IMPORT = "KW_IMPORT"
KW_IN = "KW_IN"
KW_INTERFACE = "KW_INTERFACE"
KW_INVARIANT = "KW_INVARIANT"
KW_IS = "KW_IS"
KW_LAZY = "KW_LAZY"
KW_MACRO = "KW_MACRO"
KW_MIXIN = "KW_MIXIN"
KW_MODULE = "KW_MODULE"
KW_NEW = "KW_NEW"
KW_NULL = "KW_NULL"
KW_OUT = "KW_OUT"
KW_PRAGMA = "KW_PRAGMA"
KW_RETURN = "KW_RETURN"
KW_STRUCT = "KW_STRUCT"
KW_SUPER = "KW_SUPER"
KW_SWITCH = "KW_SWITCH"
KW_TEMPLATE = "KW_TEMPLATE"
KW_THIS = "KW_THIS"
KW_THROW = "KW_THROW"
KW_TRUE = "KW_TRUE"
KW_TRY = "KW_TRY"
KW_TYPEDEF = "KW_TYPEDEF"
KW_TYPEID = "KW_TYPEID"
KW_TYPEOF = "KW_TYPEOF"
KW_UNION = "KW_UNION"
KW_UNITTEST = "KW_UNITTEST"
KW_VERSION = "KW_VERSION"
KW_VOLATILE = "KW_VOLATILE"
KW_WHILE = "KW_WHILE"
KW_WITH = "KW_WITH"
KW___TRAITS = "KW___TRAITS"
KW___GSHARED = "KW___GSHARED"
KW___THREAD = "KW___THREAD"
KW___VECTOR = "KW___VECTOR"
KW___FILE__ = "KW___FILE__"
KW___LINE__ = "KW___LINE__"
KW___MODULE__ = "KW___MODULE__"
KW___FUNCTION__ = "KW___FUNCTION__"
KW___PRETTY_FUNCTION__ = "KW___PRETTY_FUNCTION__"
KW___DATE__ = "KW___DATE__"
KW___TIME__ = "KW___TIME__"
KW___TIMESTAMP__ = "KW___TIMESTAMP__"
KW___VENDOR__ = "KW___VENDOR__"
KW___VERSION__  = "__VERSION__"  
  ]
}

module ::=
     moduleDeclaration? declaration*
     ;

 addExpression ::=
       mulExpression
     | addExpression (PLUS | MINUS | CONCAT) mulExpression
     ;

 aliasDeclaration ::=
       KW_ALIAS aliasInitializer (COMMA aliasInitializer)* SEMICOLON
     | KW_ALIAS linkageAttribute? type IDENTIFIER SEMICOLON
     ;

 aliasInitializer ::=
     IDENTIFIER ASSIGN type
     ;

 aliasThisDeclaration ::=
     KW_ALIAS IDENTIFIER KW_THIS SEMICOLON
     ;

 alignAttribute ::=
     KW_ALIGN (OPEN_PARENS GROUP_INTEGER CLOSE_PARENS)?
     ;

 andAndExpression ::=
       orExpression
     | andAndExpression LOGICAL_AND orExpression
     ;

 andExpression ::=
       cmpExpression
     | andExpression AND cmpExpression
     ;

 argumentList ::=
     assignExpression (COMMA assignExpression?)*
     ;

 arguments ::=
     OPEN_PARENS argumentList? CLOSE_PARENS
     ;

 arrayInitializer ::=
       OPEN_BRACKET CLOSE_BRACKET
     | OPEN_BRACKET arrayMemberInitialization (COMMA arrayMemberInitialization?)* CLOSE_BRACKET
     ;

 arrayLiteral ::=
     OPEN_BRACKET argumentList? CLOSE_BRACKET
     ;

 arrayMemberInitialization ::=
     (assignExpression COLON)? nonVoidInitializer
     ;

 asmAddExp ::=
       asmMulExp
     | asmAddExp (PLUS | MINUS) asmMulExp
     ;

 asmAndExp ::=
     asmEqualExp (AND asmEqualExp)?
     ;

 asmBrExp ::=
       asmUnaExp
     | asmBrExp OPEN_BRACKET asmExp CLOSE_BRACKET
     ;

 asmEqualExp ::=
     asmRelExp ((EQUALS | NOT_EQUAL) asmRelExp)?
     ;

 asmExp ::=
     asmLogOrExp (QUESTION asmExp COLON asmExp)?
     ;

 asmInstruction ::=
     IDENTIFIER
     | KW_ALIGN GROUP_INTEGER
     | KW_ALIGN IDENTIFIER
     | IDENTIFIER COLON asmInstruction
     | IDENTIFIER asmExp
     | IDENTIFIER operands
     ;

 asmLogAndExp ::=
     asmOrExp (LOGICAL_AND asmOrExp)?
     ;

 asmLogOrExp ::=
     asmLogAndExp (LOGICAL_OR asmLogAndExp)?
     ;

 asmMulExp ::=
     asmBrExp ((STAR | DIV | MOD) asmBrExp)?
     ;

 asmOrExp ::=
     asmXorExp (OR asmXorExp)?
     ;

 asmPrimaryExp ::=
       GROUP_INTEGER
     | GROUP_FLOAT
     | register
     | identifierChain
     | DOLLAR
     ;

 asmRelExp ::=
     asmShiftExp ((LESS_THAN | LESS_EQUAL | GREATER_THAN | GREATER_EQUAL) asmShiftExp)?
     ;

 asmShiftExp ::=
     asmAddExp ((LEFT_SHIFT | RIGHT_SHIFT | TRIPLE_RSHIFT) asmAddExp)?
     ;

 asmStatement ::=
     KW_ASM OPEN_BRACE asmInstruction+ CLOSE_BRACE
     ;

 asmTypePrefix ::=
       IDENTIFIER IDENTIFIER
     | KW_BYTE IDENTIFIER
     | KW_SHORT IDENTIFIER
     | KW_INT IDENTIFIER
     | KW_FLOAT IDENTIFIER
     | KW_DOUBLE IDENTIFIER
     | KW_REAL IDENTIFIER
     ;

 asmUnaExp ::=
       asmTypePrefix asmExp
     | IDENTIFIER asmExp
     | PLUS asmUnaExp
     | MINUS asmUnaExp
     | NOT asmUnaExp
     | CONCAT asmUnaExp
     | asmPrimaryExp
     ;

 asmXorExp ::=
     asmAndExp (XOR asmAndExp)?
     ;

 assertExpression ::=
     KW_ASSERT OPEN_PARENS assignExpression (COMMA assignExpression)? CLOSE_PARENS
     ;

 assignExpression ::=
     ternaryExpression (assignOperator assignExpression)?
     ;
 assignOperator ::=
       ASSIGN
     | TRIPLE_RSHIFT_ASSIGN
     | RIGHT_SHIFT_ASSIGN
     | LEFT_SHIFT_ASSIGN
     | PLUS_ASSIGN
     | MINUS_ASSIGN
     | MULT_ASSIGN
     | MOD_ASSIGN
     | AND_ASSIGN
     | DIV_ASSIGN
     | OR_ASSIGN
     | POW_ASSIGN
     | XOR_ASSIGN
     | CONCAT_ASSIGN
     ;

 assocArrayLiteral ::=
     OPEN_BRACKET keyValuePairs CLOSE_BRACKET
     ;

 atAttribute ::=
     AT (IDENTIFIER | OPEN_PARENS argumentList CLOSE_PARENS | functionCallExpression)
     ;

 attribute ::=
       alignAttribute
     | linkageAttribute
     | pragmaExpression
     | storageClass
     | KW_EXPORT
     | KW_PACKAGE
     | KW_PRIVATE
     | KW_PROTECTED
     | KW_PUBLIC
     ;

 attributeDeclaration ::=
     attribute COLON
     ;

 autoDeclaration ::=
     storageClass IDENTIFIER ASSIGN initializer (COMMA IDENTIFIER ASSIGN initializer)* SEMICOLON
     ;

 blockStatement ::=
     OPEN_BRACE declarationsAndStatements? CLOSE_BRACE
     ;

 bodyStatement ::=
     KW_BODY blockStatement
     ;

 breakStatement ::=
     KW_BREAK IDENTIFIER? SEMICOLON
     ;

 baseClass ::=
     (typeofExpression DOT)? identifierOrTemplateChain
     ;

 baseClassList ::=
     baseClass (COMMA baseClass)*
     ;

 builtinType ::=
      KW_BOOL
    | KW_BYTE
    | KW_UBYTE
    | KW_SHORT
    | KW_USHORT
    | KW_INT
    | KW_UINT
    | KW_LONG
    | KW_ULONG
    | KW_CHAR
    | KW_WCHAR
    | KW_DCHAR
    | KW_FLOAT
    | KW_DOUBLE
    | KW_REAL
    | KW_IFLOAT
    | KW_IDOUBLE
    | KW_IREAL
    | KW_CFLOAT
    | KW_CDOUBLE
    | KW_CREAL
    | KW_VOID
    ;

 caseRangeStatement ::=
     KW_CASE assignExpression COLON TRIPLE_DOT KW_CASE assignExpression COLON declarationsAndStatements
     ;

 caseStatement ::=
     KW_CASE argumentList COLON declarationsAndStatements
     ;

 castExpression ::=
     KW_CAST OPEN_PARENS (type | castQualifier)? CLOSE_PARENS unaryExpression
     ;

 castQualifier ::=
      KW_CONST
    | KW_CONST KW_SHARED
    | KW_IMMUTABLE
    | KW_INOUT
    | KW_INOUT KW_SHARED
    | KW_SHARED
    | KW_SHARED KW_CONST
    | KW_SHARED KW_INOUT
    ;

 catch_ ::=
     KW_CATCH OPEN_PARENS type IDENTIFIER? CLOSE_PARENS declarationOrStatement
     ;

 catches ::=
       catch_+
     | catch_* lastCatch
     ;

 classDeclaration ::=
       KW_CLASS IDENTIFIER (COLON baseClassList)? SEMICOLON
     | KW_CLASS IDENTIFIER (COLON baseClassList)? structBody
     | KW_CLASS IDENTIFIER templateParameters constraint? (COLON baseClassList)? structBody
     | KW_CLASS IDENTIFIER templateParameters (COLON baseClassList)? constraint? structBody
     ;

 cmpExpression ::=
       shiftExpression
     | equalExpression
     | identityExpression
     | relExpression
     | inExpression
     ;

 compileCondition ::=
       versionCondition
     | debugCondition
     | staticIfCondition
     ;

 conditionalDeclaration ::=
       compileCondition declaration
     | compileCondition COLON declaration+
     | compileCondition declaration (KW_ELSE declaration)?
     ;

 conditionalStatement ::=
     compileCondition declarationOrStatement (KW_ELSE declarationOrStatement)?
     ;

 constraint ::=
     KW_IF OPEN_PARENS expression CLOSE_PARENS
     ;

 constructor ::=
       KW_THIS templateParameters parameters memberFunctionAttribute* constraint? (functionBody | SEMICOLON)
     ;

 continueStatement ::=
     KW_CONTINUE IDENTIFIER? SEMICOLON
     ;

 debugCondition ::=
     KW_DEBUG (OPEN_PARENS (GROUP_INTEGER | IDENTIFIER) CLOSE_PARENS)?
     ;

 debugSpecification ::=
     KW_DEBUG ASSIGN (IDENTIFIER | GROUP_INTEGER) SEMICOLON
     ;

declaration ::=
     attribute* declaration2
     ;
declaration2 ::=
     aliasDeclaration
   | aliasThisDeclaration
   | classDeclaration
   | conditionalDeclaration
   | constructor
   | destructor
   | enumDeclaration
   | functionDeclaration
   | importDeclaration
   | interfaceDeclaration
   | mixinDeclaration
   | mixinTemplateDeclaration
   | pragmaDeclaration
   | sharedStaticConstructor
   | sharedStaticDestructor
   | staticAssertDeclaration
   | staticConstructor
   | staticDestructor
   | structDeclaration
   | templateDeclaration
   | unionDeclaration
   | unittest
   | variableDeclaration
   | attributeDeclaration
   | invariant
   | OPEN_BRACE declaration+ CLOSE_BRACE
   ;

 declarationsAndStatements ::=
     declarationOrStatement+
     ;

 declarationOrStatement ::=
       declaration
     | statement
     ;

 declarator ::=
     IDENTIFIER (ASSIGN initializer)?
     ;

 defaultStatement ::=
     KW_DEFAULT COLON declarationsAndStatements
     ;

 deleteExpression ::=
     KW_DELETE unaryExpression
     ;

 deprecated ::=
     KW_DEPRECATED (OPEN_PARENS assignExpression CLOSE_PARENS)?
     ;

 destructor ::=
     CONCAT KW_THIS OPEN_PARENS CLOSE_PARENS memberFunctionAttribute* (functionBody | SEMICOLON)
     ;

 doStatement ::=
     KW_DO statementNoCaseNoDefault KW_WHILE OPEN_PARENS expression CLOSE_PARENS SEMICOLON
     ;

 enumBody ::=
       SEMICOLON
     | OPEN_BRACE enumMember (COMMA enumMember?)* CLOSE_BRACE
     ;

 enumDeclaration ::=
     KW_ENUM IDENTIFIER? (COLON type)? enumBody
     ;

 enumMember ::=
       IDENTIFIER
     | (IDENTIFIER | type) ASSIGN assignExpression
     ;

 equalExpression ::=
     shiftExpression (EQUALS | NOT_EQUAL) shiftExpression
     ;

 expression ::=
     assignExpression (COMMA assignExpression)*
     ;

 expressionStatement ::=
     expression SEMICOLON
     ;

 finalSwitchStatement ::=
     KW_FINAL switchStatement
     ;

 finally_ ::=
     KW_FINALLY declarationOrStatement
     ;

 forStatement ::=
     KW_FOR OPEN_PARENS declarationOrStatement expression? SEMICOLON expression? CLOSE_PARENS declarationOrStatement
     ;

 foreachStatement ::=
       (KW_FOREACH | KW_FOREACH_REVERSE) OPEN_PARENS foreachTypeList SEMICOLON expression CLOSE_PARENS declarationOrStatement
     | (KW_FOREACH | KW_FOREACH_REVERSE) OPEN_PARENS foreachType SEMICOLON expression DOUBLE_DOT expression CLOSE_PARENS declarationOrStatement
     ;

 foreachType ::=
     typeConstructors? type? IDENTIFIER
     ;

 foreachTypeList ::=
     foreachType (COMMA foreachType)*
     ;

 functionAttribute ::=
       atAttribute
     | KW_PURE
     | KW_NOTHROW
     ;

 functionBody ::=
       blockStatement
     | (inStatement | outStatement | outStatement inStatement | inStatement outStatement)? bodyStatement
     ;

 functionCallExpression ::=
       unaryExpression templateArguments? arguments
     | type arguments
     ;

 functionCallStatement ::=
     functionCallExpression SEMICOLON
     ;

 functionDeclaration ::=
       (storageClass | type) IDENTIFIER templateParameters? parameters memberFunctionAttribute* constraint? (functionBody | SEMICOLON)
     ;

 functionLiteralExpression ::=
     ((KW_FUNCTION | KW_DELEGATE) type?)? (parameters functionAttribute*)? functionBody
     ;

 gotoStatement ::=
     KW_GOTO (IDENTIFIER | KW_DEFAULT | KW_CASE expression?) SEMICOLON
     ;

 identifierChain ::=
     IDENTIFIER (DOT IDENTIFIER)*
     ;

 identifierList ::=
     IDENTIFIER (COMMA IDENTIFIER)*
     ;

 identifierOrTemplateChain ::=
     identifierOrTemplateInstance (DOT identifierOrTemplateInstance)*
     ;

 identifierOrTemplateInstance ::=
       IDENTIFIER
     | templateInstance
     ;

 identityExpression ::=
     shiftExpression (KW_IS | NOT KW_IS) shiftExpression
     ;

 ifStatement ::=
     KW_IF OPEN_PARENS ifCondition CLOSE_PARENS declarationOrStatement (KW_ELSE declarationOrStatement)?
    ;

ifCondition ::=
       KW_AUTO IDENTIFIER ASSIGN expression
     | type IDENTIFIER ASSIGN expression
     | expression
     ;

 importBind ::=
     IDENTIFIER (ASSIGN IDENTIFIER)?
     ;

 importBindings ::=
     singleImport COLON importBind (COMMA importBind)*
     ;

 importDeclaration ::=
       KW_IMPORT singleImport (COMMA singleImport)* (COMMA importBindings)? SEMICOLON
     | KW_IMPORT importBindings SEMICOLON
     ;

 importExpression ::=
     KW_IMPORT OPEN_PARENS assignExpression CLOSE_PARENS
     ;

 indexExpression ::=
     unaryExpression OPEN_BRACKET argumentList CLOSE_BRACKET
     ;

 inExpression ::=
     shiftExpression (KW_IN | NOT KW_IN) shiftExpression
     ;

 inStatement ::=
     KW_IN blockStatement
     ;

 initialize ::=
       SEMICOLON
     | statementNoCaseNoDefault
     ;

 initializer ::=
       KW_VOID
     | nonVoidInitializer
     ;

 interfaceDeclaration ::=
     KW_INTERFACE IDENTIFIER (SEMICOLON | (templateParameters constraint?)? (COLON baseClassList)? structBody)
     ;

 invariant ::=
     KW_INVARIANT (OPEN_PARENS CLOSE_PARENS)? blockStatement
     ;

 isExpression ::=
     KW_IS OPEN_PARENS type IDENTIFIER? ((COLON | EQUALS) typeSpecialization (COMMA templateParameterList)?)? CLOSE_PARENS
     ;

 keyValuePair ::=
     assignExpression COLON assignExpression
     ;

 keyValuePairs ::=
     keyValuePair (COMMA keyValuePair)* COMMA?
     ;

 labeledStatement ::=
     IDENTIFIER COLON declarationOrStatement
     ;

 lambdaExpression ::=
       IDENTIFIER LAMBDA assignExpression
     | KW_FUNCTION parameters functionAttribute* LAMBDA assignExpression
     | KW_DELEGATE parameters functionAttribute* LAMBDA assignExpression
     | parameters functionAttribute* LAMBDA assignExpression
     ;

 lastCatch ::=
     KW_CATCH statementNoCaseNoDefault
     ;

 linkageAttribute ::=
     KW_EXTERN OPEN_PARENS IDENTIFIER (INCREMENT (COMMA identifierChain)?)? CLOSE_PARENS
     ;

 memberFunctionAttribute ::=
       functionAttribute
     | KW_IMMUTABLE
     | KW_INOUT
     | KW_SHARED
     | KW_CONST
     ;

 mixinDeclaration ::=
       mixinExpression SEMICOLON
     | templateMixinExpression SEMICOLON
     ;

 mixinExpression ::=
     KW_MIXIN OPEN_PARENS assignExpression CLOSE_PARENS
     ;

 mixinTemplateDeclaration ::=
     KW_MIXIN templateDeclaration
     ;

 mixinTemplateName ::=
       symbol
     | typeofExpression DOT identifierOrTemplateChain
     ;


 moduleDeclaration ::=
     KW_MODULE identifierChain SEMICOLON
     ;

 mulExpression ::=
       powExpression
     | mulExpression (STAR | DIV | MOD) powExpression
     ;

 newAnonClassExpression ::=
     KW_NEW arguments? KW_CLASS arguments? baseClassList? structBody
     ;

 newExpression ::=
       KW_NEW type (OPEN_BRACKET assignExpression CLOSE_BRACKET | arguments)?
     | newAnonClassExpression
     ;

 statementNoCaseNoDefault ::=
       labeledStatement
     | blockStatement
     | ifStatement
     | whileStatement
     | doStatement
     | forStatement
     | foreachStatement
     | switchStatement
     | finalSwitchStatement
     | continueStatement
     | breakStatement
     | returnStatement
     | gotoStatement
     | withStatement
     | synchronizedStatement
     | tryStatement
     | throwStatement
     | scopeGuardStatement
     | asmStatement
     | conditionalStatement
     | staticAssertStatement
     | versionSpecification
     | debugSpecification
     | expressionStatement
     ;

 nonVoidInitializer ::=
       assignExpression
     | arrayInitializer
     | structInitializer
     | functionBody
     ;

 operands ::=
     asmExp+
     ;

 orExpression ::=
       xorExpression
     | orExpression OR xorExpression
     ;

 orOrExpression ::=
       andAndExpression
     | orOrExpression LOGICAL_OR andAndExpression
     ;

 outStatement ::=
     KW_OUT (OPEN_PARENS IDENTIFIER CLOSE_PARENS)? blockStatement
     ;

 parameter ::=
     parameterAttribute* type (IDENTIFIER? TRIPLE_DOT | (IDENTIFIER? (ASSIGN assignExpression)?))?
     ;

 parameterAttribute ::=
       typeConstructor
     | KW_FINAL
     | KW_IN
     | KW_LAZY
     | KW_OUT
     | KW_REF
     | KW_SCOPE
     | KW_AUTO
     ;

 parameters ::=
       OPEN_PARENS parameter (COMMA parameter)* (COMMA TRIPLE_DOT)? CLOSE_PARENS
     | OPEN_PARENS TRIPLE_DOT CLOSE_PARENS
     | OPEN_PARENS CLOSE_PARENS
     ;

 postblit ::=
     KW_THIS OPEN_PARENS KW_THIS CLOSE_PARENS memberFunctionAttribute* (functionBody | SEMICOLON)
     ;

 postIncDecExpression ::=
     unaryExpression (INCREMENT | DECREMENT)
     ;

 powExpression ::=
       unaryExpression
     | powExpression POW unaryExpression
     ;

 pragmaDeclaration ::=
     pragmaExpression SEMICOLON
     ;

 pragmaExpression ::=
     KW_PRAGMA OPEN_PARENS IDENTIFIER (COMMA argumentList)? CLOSE_PARENS
     ;

 preIncDecExpression ::=
     (INCREMENT | DECREMENT) unaryExpression
     ;

 primaryExpression ::=
       identifierOrTemplateInstance
     | DOT identifierOrTemplateInstance
     | builtinType DOT IDENTIFIER
     | typeofExpression
     | typeidExpression
     | vector
     | arrayLiteral
     | assocArrayLiteral
     | OPEN_PARENS expression CLOSE_PARENS
     | isExpression
     | lambdaExpression
     | functionLiteralExpression
     | traitsExpression
     | mixinExpression
     | importExpression
     | DOLLAR
     | KW_THIS
     | KW_SUPER
     | KW_NULL
     | KW_TRUE
     | KW_FALSE
     | KW___DATE__
     | KW___TIME__
     | KW___TIMESTAMP__
     | KW___VENDOR__
     | KW___VERSION__
     | KW___FILE__
     | KW___LINE__
     | KW___MODULE__
     | KW___FUNCTION__
     | KW___PRETTY_FUNCTION__
     | GROUP_INTEGER
     | GROUP_FLOAT
     | GROUP_STRING+
     | CHARACTER
     ;

 register ::=
     IDENTIFIER
     | IDENTIFIER OPEN_PARENS GROUP_INTEGER CLOSE_PARENS
     ;

 relExpression ::=
       shiftExpression
     | relExpression relOperator shiftExpression
     ;
 relOperator ::=
       LESS_THAN
     | LESS_EQUAL
     | GREATER_THAN
     | GREATER_EQUAL
     | UNORDERED
     | UNORDERED_E
     | LESS_GREATER
     | LESS_GREATER_EQUAL
     | UNORDERED_LE
     | UNORDERED_L
     | UNORDERED_GE
     | UNORDERED_G
     ;

 returnStatement ::=
     KW_RETURN expression? SEMICOLON
     ;

 scopeGuardStatement ::=
     KW_SCOPE OPEN_PARENS IDENTIFIER CLOSE_PARENS statementNoCaseNoDefault
     ;

 sharedStaticConstructor ::=
     KW_SHARED KW_STATIC KW_THIS OPEN_PARENS CLOSE_PARENS functionBody
     ;

 sharedStaticDestructor ::=
     KW_SHARED KW_STATIC CONCAT KW_THIS OPEN_PARENS CLOSE_PARENS functionBody
     ;

 shiftExpression ::=
       addExpression
     | shiftExpression (LEFT_SHIFT | RIGHT_SHIFT | TRIPLE_RSHIFT) addExpression
     ;

 singleImport ::=
     (IDENTIFIER ASSIGN)? identifierChain
     ;

 sliceExpression ::=
       unaryExpression OPEN_BRACKET assignExpression DOUBLE_DOT assignExpression CLOSE_BRACKET
     | unaryExpression OPEN_BRACKET CLOSE_BRACKET
     ;

 statement ::=
       statementNoCaseNoDefault
     | caseStatement
     | caseRangeStatement
     | defaultStatement
     ;

 staticAssertDeclaration ::=
     staticAssertStatement
     ;

 staticAssertStatement ::=
     KW_STATIC assertExpression SEMICOLON
     ;

 staticConstructor ::=
     KW_STATIC KW_THIS OPEN_PARENS CLOSE_PARENS functionBody
     ;

 staticDestructor ::=
     KW_STATIC CONCAT KW_THIS OPEN_PARENS CLOSE_PARENS functionBody
     ;

 staticIfCondition ::=
     KW_STATIC KW_IF OPEN_PARENS assignExpression CLOSE_PARENS
     ;

 storageClass ::=
       atAttribute
     | typeConstructor
     | deprecated
     | KW_ABSTRACT
     | KW_AUTO
     | KW_ENUM
     | KW_EXTERN
     | KW_FINAL
     | KW_NOTHROW
     | KW_OVERRIDE
     | KW_PURE
     | KW_REF
     | KW___GSHARED
     | KW_SCOPE
     | KW_STATIC
     | KW_SYNCHRONIZED
     ;

 structBody ::=
     OPEN_BRACE declaration* CLOSE_BRACE
     ;

 structDeclaration ::=
     KW_STRUCT IDENTIFIER? (templateParameters constraint? structBody | (structBody | SEMICOLON))
     ;

 structInitializer ::=
     OPEN_BRACE structMemberInitializers? CLOSE_BRACE
     ;

 structMemberInitializer ::=
     (IDENTIFIER COLON)? nonVoidInitializer
     ;

 structMemberInitializers ::=
     structMemberInitializer (COMMA structMemberInitializer?)*
     ;

 switchStatement ::=
     KW_SWITCH OPEN_PARENS expression CLOSE_PARENS statement
     ;

 symbol ::=
     DOT? identifierOrTemplateChain
     ;

 synchronizedStatement ::=
     KW_SYNCHRONIZED (OPEN_PARENS expression CLOSE_PARENS)? statementNoCaseNoDefault
     ;

 templateAliasParameter ::=
     KW_ALIAS type? IDENTIFIER (COLON (type | assignExpression))? (ASSIGN (type | assignExpression))?
     ;

 templateArgument ::=
       type
     | assignExpression
     ;

 templateArgumentList ::=
     templateArgument (COMMA templateArgument?)*
     ;

 templateArguments ::=
     NOT (OPEN_PARENS templateArgumentList? CLOSE_PARENS | templateSingleArgument)
     ;

 templateDeclaration ::=
       KW_TEMPLATE IDENTIFIER templateParameters constraint? OPEN_BRACE declaration* CLOSE_BRACE
     | eponymousTemplateDeclaration
     ;

 eponymousTemplateDeclaration ::=
     KW_ENUM IDENTIFIER templateParameters ASSIGN assignExpression SEMICOLON
     ;

 templateInstance ::=
     IDENTIFIER templateArguments
     ;

 templateMixinExpression ::=
     KW_MIXIN mixinTemplateName templateArguments? IDENTIFIER?
     ;

 templateParameter ::=
       templateTypeParameter
     | templateValueParameter
     | templateAliasParameter
     | templateTupleParameter
     | templateThisParameter
     ;

 templateParameterList ::=
     templateParameter (COMMA templateParameter?)*
     ;

 templateParameters ::=
     OPEN_PARENS templateParameterList? CLOSE_PARENS
     ;

 templateSingleArgument ::=
       builtinType
     | IDENTIFIER
     | CHARACTER
     | GROUP_STRING
     | GROUP_INTEGER
     | GROUP_FLOAT
     | KW_TRUE
     | KW_FALSE
     | KW_NULL
     | KW_THIS
     | KW___DATE__
     | KW___TIME__
     | KW___TIMESTAMP__
     | KW___VENDOR__
     | KW___VERSION__
     | KW___FILE__
     | KW___LINE__
     | KW___MODULE__
     | KW___FUNCTION__
     | KW___PRETTY_FUNCTION__
     ;

 templateThisParameter ::=
     KW_THIS templateTypeParameter
     ;

 templateTupleParameter ::=
     IDENTIFIER TRIPLE_DOT
     ;

 templateTypeParameter ::=
     IDENTIFIER (COLON type)? (ASSIGN type)?
     ;

 templateValueParameter ::=
     type IDENTIFIER (COLON expression)? templateValueParameterDefault?
     ;

 templateValueParameterDefault ::=
     ASSIGN (KW___FILE__ | KW___MODULE__ | KW___LINE__ | KW___FUNCTION__ | KW___PRETTY_FUNCTION__ | assignExpression)
     ;

 ternaryExpression ::=
     orOrExpression (QUESTION expression COLON ternaryExpression)?
     ;

 throwStatement ::=
     KW_THROW expression SEMICOLON
     ;

 traitsExpression ::=
     KW___TRAITS OPEN_PARENS IDENTIFIER COMMA templateArgumentList CLOSE_PARENS
     ;

 tryStatement ::=
     KW_TRY declarationOrStatement ((catches finally_?) | finally_)
     ;

 type ::=
     attribute? type2 typeSuffix*
     ;

 type2 ::=
       builtinType
     | symbol
     | typeofExpression (DOT identifierOrTemplateChain)?
     | typeConstructor OPEN_PARENS type CLOSE_PARENS
     ;

 typeConstructor ::=
       KW_CONST
     | KW_IMMUTABLE
     | KW_INOUT
     | KW_SHARED
     | KW_SCOPE
     ;

 typeConstructors ::=
     typeConstructor+
     ;

 typeSpecialization ::=
       type
     | KW_STRUCT
     | KW_UNION
     | KW_CLASS
     | KW_INTERFACE
     | KW_ENUM
     | KW_FUNCTION
     | KW_DELEGATE
     | KW_SUPER
     | KW_CONST
     | KW_IMMUTABLE
     | KW_INOUT
     | KW_SHARED
     | KW_RETURN
     | KW_TYPEDEF
     ;

 typeSuffix ::=
       STAR
     | OPEN_BRACKET type? CLOSE_BRACKET
     | OPEN_BRACKET assignExpression CLOSE_BRACKET
     | OPEN_BRACKET assignExpression DOUBLE_DOT  assignExpression CLOSE_BRACKET
     | (KW_DELEGATE | KW_FUNCTION) parameters memberFunctionAttribute*
     ;

 typeidExpression ::=
     KW_TYPEID OPEN_PARENS (type | expression) CLOSE_PARENS
     ;

 typeofExpression ::=
     KW_TYPEOF OPEN_PARENS (expression | KW_RETURN) CLOSE_PARENS
     ;

unaryExpression ::=
      primaryExpression
    | AND unaryExpression
    | NOT unaryExpression
    | STAR unaryExpression
    | PLUS unaryExpression
    | MINUS unaryExpression
    | CONCAT unaryExpression
    | INCREMENT unaryExpression
    | DECREMENT unaryExpression
    | unaryExpression templateArguments? arguments
    | unaryExpression OPEN_BRACKET assignExpression DOUBLE_DOT assignExpression CLOSE_BRACKET
    | unaryExpression OPEN_BRACKET CLOSE_BRACKET
    | unaryExpression OPEN_BRACKET argumentList CLOSE_BRACKET
    | newExpression
    | deleteExpression
    | castExpression
    | assertExpression
    | OPEN_PARENS type CLOSE_PARENS DOT identifierOrTemplateInstance
    | unaryExpression DOT identifierOrTemplateInstance
    | unaryExpression DECREMENT
    | unaryExpression INCREMENT
    ;

 unionDeclaration ::=
       KW_UNION IDENTIFIER templateParameters constraint? structBody
     | KW_UNION IDENTIFIER (structBody | SEMICOLON)
     | KW_UNION structBody
     ;

 unittest ::=
     KW_UNITTEST blockStatement
     ;

 variableDeclaration ::=
       type declarator (COMMA declarator)* SEMICOLON
     | type declarator ASSIGN functionBody
     | autoDeclaration
     ;

 vector ::=
     KW___VECTOR OPEN_PARENS type CLOSE_PARENS
     ;

 versionCondition ::=
     KW_VERSION OPEN_PARENS (GROUP_INTEGER | IDENTIFIER | KW_UNITTEST | KW_ASSERT) CLOSE_PARENS
     ;

 versionSpecification ::=
     KW_VERSION ASSIGN (IDENTIFIER | GROUP_INTEGER) SEMICOLON
     ;

 whileStatement ::=
     KW_WHILE OPEN_PARENS expression CLOSE_PARENS declarationOrStatement
     ;

 withStatement ::=
     KW_WITH OPEN_PARENS expression CLOSE_PARENS statementNoCaseNoDefault
     ;

 xorExpression ::=
       andExpression
     | xorExpression XOR andExpression
     ;





